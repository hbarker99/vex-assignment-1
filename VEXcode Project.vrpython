{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\ndrivetrain.set_drive_velocity(100, PERCENT)\n\n#endregion VEXcode Generated Robot Configuration\nimport random\n\n\nclass DiscoveryInstruction:\n    FASTEST = 1\n    SLOWEST = 2\n    CHECKRIGHT = 3\n    CHECKLEFT = 4\n\nclass DirectionInstruction:\n    RotationDirection = LEFT\n    Rotations = 0\n\n    def __init__(self, direction, rotations):\n        self.RotationDirection = direction\n        self.Rotations = rotations\n\nclass Direction:\n    NORTH = 0\n    EAST = 1\n    SOUTH = 2\n    WEST = 3\n\n    @staticmethod\n    def FastestRotation(current, final):\n        difference = current - final\n\n        if (difference == 0):\n            return DirectionInstruction(RIGHT, 0)\n\n        if (difference == -1 or difference == 3):\n            return DirectionInstruction(RIGHT, 1)\n        \n        if (difference == 2 or difference == -2):\n            return DirectionInstruction(RIGHT, 2)\n        \n        return DirectionInstruction(LEFT, 1)\n    \n    @staticmethod\n    def ReverseDirection(direction):\n        revDirection = direction - 2\n        if (revDirection < 0):\n            revDirection = revDirection + 4\n\n        return revDirection\n    \n    @staticmethod\n    def RequiredDirection(startPos, endPos):\n        required = Direction.NORTH\n\n        if (startPos.x < endPos.x):\n            required = Direction.EAST\n\n        elif (startPos.x > endPos.x):\n            required = Direction.WEST\n\n        elif (startPos.y < endPos.y):\n            required = Direction.SOUTH\n\n        return required\n    \n    def RightFrom(direction):\n        return direction + 1 if direction != Direction.WEST else Direction.NORTH\n    \n    def LeftFrom(direction):\n        return direction - 1 if direction != Direction.NORTH else Direction.WEST\n        \n\n\nclass Point:\n    x = 0\n    y = 0\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def NextPosition(self, direction):\n\n        vertModifier = 0\n        horizModifier = 0\n\n        if (direction == Direction.NORTH):\n            vertModifier = -1\n            \n        elif (direction == Direction.EAST):\n            horizModifier = 1\n            \n        if (direction == Direction.SOUTH):\n            vertModifier = 1\n\n        if (direction == Direction.WEST):\n            horizModifier = -1\n\n        return Point(self.x + horizModifier, self.y + vertModifier)\n\nclass Tile:\n    Pos = Point(0, 0)\n    AvailableDirections = [True, True, True, True] #North, East, South, West\n    CheckedDirections = [False, False, False, False] \n\n    def __init__(self, x, y):\n        self.Pos = Point(x, y)\n        self.AvailableDirections = [True, True, True, True] #North, East, South, West\n        self.CheckedDirections = [False, False, False, False] \n\n    def IsDiscovered(self):\n        return all(self.CheckedDirections)\n    \n    def GetDiscoveryInstruction(self, currentDirection, finalDirection, discoveryPercent):\n        #When entering a tile we know whether it has a wall behind it, and if it has a tile in front of it. So can work with that assumption.\n        undiscoveredDirections = self.CheckedDirections.count(False)\n\n        if (undiscoveredDirections == 0 or discoveryPercent > 0.5):\n            return DiscoveryInstruction.FASTEST\n        \n        if (currentDirection == finalDirection):\n            #If there is 1 undiscovered and we want to end up facing the same direction, we just want to check that direction and then point back again\n            #This is 2 rotations, as opposed to 4 if we just went the slowest way.\n            if (undiscoveredDirections == 1):\n                rightDirection = Direction.RightFrom(currentDirection)\n                return DiscoveryInstruction.CHECKRIGHT if not self.CheckedDirections[rightDirection] else DiscoveryInstruction.CHECKLEFT\n\n            #If there are 2 it doesn't matter so may aswell go in the same direction 4 times\n            else:\n                return DiscoveryInstruction.SLOWEST\n        \n        #If we have already checked the end direction we know we need to go around backwards as unchecked is opposite\n        if (self.CheckedDirections[finalDirection]):\n            return DiscoveryInstruction.SLOWEST\n        \n        else:\n            return DiscoveryInstruction.FASTEST if undiscoveredDirections == 1 else DiscoveryInstruction.SLOWEST\n    \n    def UpdateInfo(self, direction, hasWall):\n        self.AvailableDirections[direction] = not hasWall\n        self.CheckedDirections[direction] = True\n    \nclass Board:\n    Map = []\n    MapWidth = 8\n    MapHeight = 8\n    Discovered = 0\n\n    def __init__(self):\n        self.Map = []\n        self.MapWidth = 8\n        self.MapHeight = 8\n        self.Discovered = (self.MapWidth * 2) + (self.MapHeight * 2)\n\n        for y in range(self.MapHeight):\n            self.Map.append([])\n            for x in range(self.MapWidth):\n                self.Map[y].append(Tile(x, y))\n\n        for y in range(self.MapHeight):\n            self.Map[y][0].AvailableDirections[Direction.WEST] = False\n            self.Map[y][0].CheckedDirections[Direction.WEST] = True\n            self.Map[y][self.MapWidth-1].AvailableDirections[Direction.EAST] = False\n            self.Map[y][self.MapWidth-1].CheckedDirections[Direction.EAST] = True\n\n        for x in range(self.MapWidth):\n            self.Map[0][x].AvailableDirections[Direction.NORTH] = False\n            self.Map[0][x].CheckedDirections[Direction.NORTH] = True\n            self.Map[self.MapHeight-1][x].AvailableDirections[Direction.SOUTH] = False\n            self.Map[self.MapHeight-1][x].CheckedDirections[Direction.SOUTH] = True\n\n    def Discover(self, startPos, direction, closestWall):\n        if (closestWall == -1):\n            return\n\n        horizChange = 0\n        vertChange = 0\n\n        if (direction == Direction.NORTH or direction == Direction.SOUTH):\n            vertChange = direction - 1\n\n        else:\n            horizChange = (- direction) + 2\n\n        for i in range(closestWall + 1):\n            tile = self.Map[startPos.y+int(vertChange*i)][startPos.x+int(horizChange*i)]\n            if (not tile.CheckedDirections[direction]):\n                tile.UpdateInfo(direction, i == closestWall)\n                self.Discovered = self.Discovered + 1\n\n        for i in range(closestWall + 1, 0, -1):\n            if (self.ExceedsMapBounds(Point(startPos.x + (horizChange * i), startPos.y + (vertChange * i)))):\n                continue\n\n            tile = self.Map[startPos.y+(vertChange*i)][startPos.x+int(horizChange*i)]\n            if (not tile.CheckedDirections[direction]):\n                self.Discovered = self.Discovered + 1\n                tile.UpdateInfo(Direction.ReverseDirection(direction), i == closestWall + 1)\n\n\n    def DiscoveryPercentage(self):\n        return float((self.Discovered) / (self.MapWidth * self. MapHeight * 4))\n\n    def ExceedsMapBounds(self, currentPos):\n        return currentPos.x < 0 or currentPos.x >= self.MapWidth or currentPos.y < 0 or currentPos.y >= self.MapHeight\n    \n    def GetTile(self, pos):\n        if (self.ExceedsMapBounds(pos)):\n            return Tile(0, 0)\n        \n        return self.Map[pos.y][pos.x]\n    \n\n    def PrintBoard(self, route, turtle):\n        for y in range(-1, self.MapHeight + 1):\n            brain.print('#')\n            for x in range(0, self.MapWidth):\n                if (y == -1):\n                    brain.print('#')\n                elif (y == self.MapWidth):\n                    brain.print('#')\n                elif (x == turtle.Pos.x and y == turtle.Pos.y):\n                    brain.set_print_color(GREEN)\n                    brain.print('T')\n                    brain.set_print_color(BLACK)\n                elif (x == turtle.Goal.x and y == turtle.Goal.y):\n                    brain.set_print_color(RED)\n                    brain.print('G')\n                    brain.set_print_color(BLACK)\n                elif ((x, y) in [(pos.x, pos.y) for pos in route]):\n                    brain.set_print_color(BLUE)\n                    brain.print('P')\n                    brain.set_print_color(BLACK)\n                else:\n                    brain.print(' ')\n            brain.print('#')\n            brain.new_line()\n\nclass AStar:\n    Route = []\n    Goal = Point(0, 0)\n    Calculations = 0\n\n    class Node:\n        def __init__(self, x, y, totalCost, currentCost, node):\n            self.x = x\n            self.y = y\n            self.TotalCost = totalCost\n            self.CurrentCost = currentCost\n            self.PreviousNode = node\n\n    def __init__(self, goal):\n        self.Goal = goal\n\n    def Heuristic(self, point):\n        return abs(self.Goal.x - point.x) + abs(self.Goal.y - point.y)\n    \n    def GetRoute(self, finalNode):\n        route = []\n        checkingNode = finalNode\n\n        while (checkingNode.PreviousNode != None):\n            route.append(Point(checkingNode.x, checkingNode.y))\n            checkingNode = checkingNode.PreviousNode\n\n        route.reverse()\n        return route\n\n    def CalculateRoute(self, current, theMap):\n        self.Calculations = self.Calculations + 1\n        self.Current = current\n        self.Route = []\n\n        routeFound = False\n        checkOrder = [self.Node(current.x, current.y, self.Heuristic(current), 0, None)]\n\n        while (not routeFound):\n            if (len(checkOrder) == 0):\n                return [Point(0, 0)]\n\n            currentNode = checkOrder.pop(0)\n            nodeRoute = [(x.x, x.y) for x in self.GetRoute(currentNode)]\n            availableDirections = theMap.Map[currentNode.y][currentNode.x].AvailableDirections\n\n            for i in range(len(availableDirections)):\n                if (not availableDirections[i]):\n                    continue\n\n                checkingPoint = Point(currentNode.x, currentNode.y)\n                checkingPoint = checkingPoint.NextPosition(int(i))\n                \n                if (currentNode.PreviousNode != None and (checkingPoint.x, checkingPoint.y) in nodeRoute):\n                    continue\n\n                stepCost = currentNode.CurrentCost + 1\n                totalCost = self.Heuristic(checkingPoint) + stepCost\n                finalNode = self.Node(checkingPoint.x, checkingPoint.y, totalCost, stepCost, currentNode)\n\n                if ((finalNode.x, finalNode.y) == (self.Goal.x, self.Goal.y)):\n                    routeFound = True\n                    self.Route = self.GetRoute(finalNode)\n                    break\n\n                if (len(checkOrder) == 0):\n                    checkOrder.append(finalNode)\n\n                inserted = False\n                removing = False\n\n                removeAt = 0\n                insertAt = 0\n\n                for node in range(len(checkOrder)):\n                    if (not inserted and finalNode.TotalCost <= checkOrder[node].TotalCost):\n                        insertAt = node\n                        inserted = True\n\n                    if ((finalNode.x, finalNode.y) == (checkOrder[node].x, checkOrder[node].y)):\n                        if (inserted):\n                            removing = True\n                            removeAt = node\n                            break\n                        else:\n                            break\n\n                if (inserted):\n                    checkOrder.insert(insertAt, finalNode)\n\n                if (removing):\n                    checkOrder.pop(removeAt)\n\n                elif(not removing and not inserted):\n                    checkOrder.append(finalNode)\n\n        if (not routeFound):\n            brain.print(\"No route to goal was found.\")\n        \n        return self.Route\n                               \n        \n\n\nclass TurtleInfo:\n    CurrentDirection = Direction.NORTH\n    Pos = Point(0, 0)\n    Goal = Point(0, 0)\n\n\n    def __init__(self, direction, start, goal):\n        self.Pos = start\n        self.Goal = goal\n        self.CurrentDirection = direction\n\n    def Turn(self, direction):\n        drivetrain.turn_for(direction, 90, DEGREES)\n        if (direction == RIGHT):\n            self.CurrentDirection = Direction.RightFrom(self.CurrentDirection)\n\n        else:\n            self.CurrentDirection = Direction.LeftFrom(self.CurrentDirection)\n\n    def Forward(self):\n        #Drive Forward\n        drivetrain.drive_for(FORWARD, 250, MM, wait=True)\n\n        self.Pos = self.Pos.NextPosition(self.CurrentDirection)\n\n    def TileSensorDistance(self):\n        if (self.CurrentDirection == Direction.NORTH):\n            return 42\n\n        elif (self.CurrentDirection == Direction.EAST):\n            return 32\n\n        elif (self.CurrentDirection == Direction.SOUTH):\n            return 33\n\n        elif (self.CurrentDirection == Direction.WEST):\n            return 42\n\n\n    def ClosestWall(self):\n        wait(1, MSEC)\n        distance = front_distance.get_distance(MM)\n        if (distance >= 3000):\n            return -1\n\n        tiles = round(round((distance - self.TileSensorDistance()) / 10) / 25)\n        if (0.8 > (distance - (250 * tiles)) / self.TileSensorDistance() > 1.2):\n            brain.set_print_color(BLUE)\n            brain.print(\"ALERT WAY OUT OF WHACK\")\n            brain.new_line()\n            brain.print(\"Direction: \" + str(self.CurrentDirection))\n            brain.new_line()\n            brain.print(\"Distance: \" + str(distance))\n            brain.new_line()\n            brain.print(\"Expected Tiles: \" + str(tiles))\n            brain.new_line()\n            brain.print(\"Makes it: \" + str(distance - (250 * tiles)))\n            brain.new_line()\n            brain.print(\"------\")\n        \n        brain.new_line()\n\n        #wait(1000, MSEC)\n\n        return tiles\n\n\ndef NextInstruction(currentPos, nextPos):\n    global board, turtle\n\n\n    nextDirection = Direction.RequiredDirection(currentPos, nextPos)\n    currentTile = board.GetTile(currentPos)\n\n    if (nextDirection == turtle.CurrentDirection and turtle.ClosestWall() == 0):\n        return False\n\n    instruction = Direction.FastestRotation(turtle.CurrentDirection, nextDirection)\n    discoveryInstruction = currentTile.GetDiscoveryInstruction(turtle.CurrentDirection, nextDirection, board.DiscoveryPercentage())\n    \"\"\"\n    brain.new_line()\n    brain.print(\"---Next Instruction---\")\n    brain.new_line()\n    brain.print(\"Current Pos X: \" + str(turtle.Pos.x) + \"  y: \" + str(turtle.Pos.y))\n    brain.new_line()\n    brain.print(\"Next Tile X: \" + str(nextPos.x) + \"  y: \" + str(nextPos.y))\n    brain.new_line()\n    brain.print(\"Current Direction: \" + str(turtle.CurrentDirection))\n    brain.new_line()\n    brain.print(\"Next Direction: \" + str(nextDirection))\n    brain.new_line()\n    brain.new_line()\n    brain.new_line()\n    \"\"\"\n\n    if (discoveryInstruction != DiscoveryInstruction.FASTEST):\n        if (discoveryInstruction == DiscoveryInstruction.CHECKLEFT):\n            Turn(LEFT)\n            Turn(RIGHT)\n        \n        elif (discoveryInstruction == DiscoveryInstruction.CHECKRIGHT):\n            Turn(RIGHT)\n            Turn(LEFT)\n\n        else:\n            rotations = 4 - instruction.Rotations\n            instruction.Rotations = rotations\n            instruction.RotationDirection = RIGHT if instruction.RotationDirection == LEFT else LEFT\n    \"\"\"\n    brain.print(\"Decision: \")\n    if (discoveryInstruction == DiscoveryInstruction.CHECKLEFT):\n        brain.print(\"Check Left\")\n    elif (discoveryInstruction == DiscoveryInstruction.CHECKRIGHT):\n        brain.print(\"Check Right\")\n    elif (discoveryInstruction == DiscoveryInstruction.FASTEST):\n        brain.print(\"Fastest\")\n    elif (discoveryInstruction == DiscoveryInstruction.SLOWEST):\n        brain.print(\"Slowest\")\n\n    brain.new_line()\n    brain.print(\"Turn Right?: \" + str(instruction.RotationDirection == RIGHT))\n    brain.new_line()\n    brain.print(\"Rotations: \" + str(instruction.Rotations))\n    brain.new_line()\n    \"\"\"\n\n    for i in range(instruction.Rotations):\n        Turn(instruction.RotationDirection)\n\n    if (turtle.ClosestWall() == 0):\n        brain.print(\"There's a wall in front.\")\n        brain.new_line()\n        return False\n\n    brain.print(\"Instruction Successful.\")\n    brain.new_line()\n    \n    Forward()\n    return True\n\ndef Forward():\n    global board, turtle\n\n    turtle.Forward()\n    board.Discover(turtle.Pos, turtle.CurrentDirection, turtle.ClosestWall())\n\n\ndef Turn(direction):\n    global board, turtle\n\n    turtle.Turn(direction)\n    board.Discover(turtle.Pos, turtle.CurrentDirection, turtle.ClosestWall())\n\n\nstartPos = Point(4, 7) #X, Y\nendPos = Point(3, 0)\nboard = Board()\n\nturtle = TurtleInfo(Direction.NORTH, startPos, endPos)\n\n\ndef PrintExpectedRoute(route):\n    for pos in route:\n        brain.print(\"Step X: \" + str(pos.x) + \"    y: \" + str(pos.y))\n        brain.new_line()\n\n\ndef Main():\n    global board, turtle\n    calculator = AStar(turtle.Goal)\n    route = calculator.CalculateRoute(turtle.Pos, board)\n\n    drivetrain.drive_for(FORWARD, 20, MM)\n    board.Discover(turtle.Pos, turtle.CurrentDirection, turtle.ClosestWall())\n\n    while ((turtle.Pos.x, turtle.Pos.y) != (turtle.Goal.x, turtle.Goal.y)):\n        \"\"\"\n        brain.print(\"---Calculations: \" + str(calculator.Calculations) + \"---\")\n        brain.new_line()\n        brain.print(\"---While Loop Top---\")\n        brain.new_line()\n        brain.print(\"Steps Remaining: \" + str(len(route)))\n        brain.new_line()\n        PrintExpectedRoute(route)\n        brain.new_line()\n        \"\"\"\n        board.PrintBoard(route, turtle)\n        brain.print(\"Discovered \")\n        brain.print(board.DiscoveryPercentage() * 100)\n        brain.print(\"%\")\n        brain.new_line()\n        nextPos = route.pop(0)\n\n\n        success = NextInstruction(turtle.Pos, nextPos)\n        if (not success):\n            brain.print(\"Not successful...\")\n            brain.new_line()\n            route = calculator.CalculateRoute(turtle.Pos, board)\n\n\nbrain.clear()\nvr_thread(Main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}