{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\ndrivetrain.set_drive_velocity(100, PERCENT)\n\nclass DiscoveryInstruction:\n    FASTEST = 1\n    SLOWEST = 2\n    CHECKRIGHT = 3\n    CHECKLEFT = 4\n\nclass DirectionInstruction:\n    RotationDirection = LEFT\n    Rotations = 0\n\n    def __init__(self, direction, rotations):\n        self.RotationDirection = direction\n        self.Rotations = rotations\n\nclass Direction:\n    NORTH = 0\n    EAST = 1\n    SOUTH = 2\n    WEST = 3\n\n    @staticmethod\n    def FastestRotation(current, final):\n        difference = current - final\n\n        if (difference == 0):\n            return DirectionInstruction(RIGHT, 0)\n\n        if (difference == -1 or difference == 3):\n            return DirectionInstruction(RIGHT, 1)\n        \n        if (difference == 2 or difference == -2):\n            return DirectionInstruction(RIGHT, 2)\n        \n        return DirectionInstruction(LEFT, 1)\n    \n    @staticmethod\n    def ReverseDirection(direction):\n        revDirection = direction - 2\n        if (revDirection < 0):\n            revDirection = revDirection + 4\n\n        return revDirection\n    \n    @staticmethod\n    def RequiredDirection(startPos, endPos):\n        required = Direction.NORTH\n\n        if (startPos.x < endPos.x):\n            required = Direction.EAST\n\n        elif (startPos.x > endPos.x):\n            required = Direction.WEST\n\n        elif (startPos.y < endPos.y):\n            required = Direction.SOUTH\n\n        return required\n\n    @staticmethod\n    def RightFrom(direction):\n        return direction + 1 if direction != Direction.WEST else Direction.NORTH\n    \n    @staticmethod\n    def LeftFrom(direction):\n        return direction - 1 if direction != Direction.NORTH else Direction.WEST\n        \n\n\nclass Point:\n    x = 0\n    y = 0\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def NextPosition(self, direction):\n\n        vertModifier = 0\n        horizModifier = 0\n\n        if (direction == Direction.NORTH):\n            vertModifier = -1\n            \n        elif (direction == Direction.EAST):\n            horizModifier = 1\n            \n        if (direction == Direction.SOUTH):\n            vertModifier = 1\n\n        if (direction == Direction.WEST):\n            horizModifier = -1\n\n        return Point(self.x + horizModifier, self.y + vertModifier)\n\nclass Tile:\n    Pos = Point(0, 0)\n    AvailableDirections = [True, True, True, True] #North, East, South, West\n    CheckedDirections = [False, False, False, False] \n\n    def __init__(self, x, y):\n        self.Pos = Point(x, y)\n        self.AvailableDirections = [True, True, True, True] #North, East, South, West\n        self.CheckedDirections = [False, False, False, False] \n\n    def IsDiscovered(self):\n        return all(self.CheckedDirections)\n    \n    def GetDiscoveryInstruction(self, currentDirection, finalDirection, discoveryPercent):\n        #When entering a tile we know whether it has a wall behind it, and if it has a tile in front of it. So can work with that assumption.\n        undiscoveredDirections = self.CheckedDirections.count(False)\n\n        if (undiscoveredDirections == 0 or discoveryPercent > 0.5):\n            return DiscoveryInstruction.FASTEST\n\n        if (currentDirection == finalDirection):\n            #If there is 1 undiscovered and we want to end up facing the initial direction, we just want to check that direction and then point back again\n            #This is 2 rotations, as opposed to 4 if we just went the slowest way.\n            if (undiscoveredDirections == 1):\n                rightDirection = Direction.RightFrom(currentDirection)\n                return DiscoveryInstruction.CHECKRIGHT if not self.CheckedDirections[rightDirection] else DiscoveryInstruction.CHECKLEFT\n\n            #If there are 2 it doesn't matter so may aswell go in the same direction 4 times\n            else:\n                return DiscoveryInstruction.SLOWEST\n        \n        #If we have already checked the end direction we know we need to go around backwards as unchecked is opposite\n        if (self.CheckedDirections[finalDirection]):\n            return DiscoveryInstruction.SLOWEST\n        \n        else:\n            return DiscoveryInstruction.FASTEST if undiscoveredDirections == 1 else DiscoveryInstruction.SLOWEST\n    \n    def UpdateInfo(self, direction, hasWall):\n        self.AvailableDirections[direction] = not hasWall\n        self.CheckedDirections[direction] = True\n    \nclass Board:\n    Map = []\n    MapWidth = 8\n    MapHeight = 8\n    DiscoveredTiles = 0\n\n    def __init__(self):\n        self.Map = []\n        self.MapWidth = 8\n        self.MapHeight = 8\n        self.DiscoveredTiles = (self.MapWidth * 2) + (self.MapHeight * 2)\n\n        for y in range(self.MapHeight):\n            self.Map.append([])\n            for x in range(self.MapWidth):\n                self.Map[y].append(Tile(x, y))\n\n        for y in range(self.MapHeight):\n            self.Map[y][0].AvailableDirections[Direction.WEST] = False\n            self.Map[y][0].CheckedDirections[Direction.WEST] = True\n            self.Map[y][self.MapWidth-1].AvailableDirections[Direction.EAST] = False\n            self.Map[y][self.MapWidth-1].CheckedDirections[Direction.EAST] = True\n\n        for x in range(self.MapWidth):\n            self.Map[0][x].AvailableDirections[Direction.NORTH] = False\n            self.Map[0][x].CheckedDirections[Direction.NORTH] = True\n            self.Map[self.MapHeight-1][x].AvailableDirections[Direction.SOUTH] = False\n            self.Map[self.MapHeight-1][x].CheckedDirections[Direction.SOUTH] = True\n\n    def Discover(self, startPos, direction, closestWall):\n        if (closestWall == -1):\n            #If no wall was spotted then it's looking out of the map. So there are no walls between here and the edge.\n            if (direction == Direction.NORTH):\n                closestWall = startPos.y\n\n            elif (direction == Direction.EAST):\n                closestWall = (self.MapWidth - 1) - startPos.x\n\n            elif (direction == Direction.SOUTH):\n                closestWall = (self.MapHeight - 1) - startPos.y\n\n            else:\n                closestWall = startPos.x\n\n        horizChange = 0\n        vertChange = 0\n\n        if (direction == Direction.NORTH or direction == Direction.SOUTH):\n            vertChange = direction - 1\n\n        else:\n            horizChange = (- direction) + 2\n\n        #For every wall between here and where it can see update the info\n        for i in range(closestWall + 1):\n            tile = self.Map[startPos.y+int(vertChange*i)][startPos.x+int(horizChange*i)]\n            if (not tile.CheckedDirections[direction]):\n                tile.UpdateInfo(direction, i == closestWall)\n                self.DiscoveredTiles = self.DiscoveredTiles + 1\n\n        #Also update the reverse direction\n        reverseDirection = Direction.ReverseDirection(direction)\n        for i in range(closestWall + 1, 0, -1):\n            if (self.ExceedsMapBounds(Point(startPos.x + (horizChange * i), startPos.y + (vertChange * i)))):\n                continue\n\n            tile = self.Map[startPos.y+(vertChange*i)][startPos.x+int(horizChange*i)]\n            if (not tile.CheckedDirections[reverseDirection]):\n                self.DiscoveredTiles = self.DiscoveredTiles + 1\n                tile.UpdateInfo(reverseDirection, i == closestWall + 1)\n        \n\n    def DiscoveryPercentage(self):\n        return float((self.DiscoveredTiles) / (self.MapWidth * self. MapHeight * 4))\n\n    def ExceedsMapBounds(self, currentPos):\n        return currentPos.x < 0 or currentPos.x >= self.MapWidth or currentPos.y < 0 or currentPos.y >= self.MapHeight\n    \n    def GetTile(self, pos):\n        if (self.ExceedsMapBounds(pos)):\n            return Tile(0, 0)\n        \n        return self.Map[pos.y][pos.x]\n    \n    def GetNextUndiscoveredTile(self):\n        for y in range(self.MapHeight):\n            for x in range(self.MapWidth):\n                if (not self.Map[y][x].IsDiscovered()):\n                    PrintLine(\"Found Undiscovered\")\n                    return Point(x, y)\n\n    \n    def GetCharacter(self, currentTile, direction):\n\n        isChecked = currentTile.CheckedDirections[direction]\n        isAvailable = currentTile.AvailableDirections[direction]\n\n        if (not isChecked):\n            return '?'\n        \n        return ' ' if isAvailable else '#'\n\n    \n    def PrintBoard(self, turtle, route=None):\n        tupleRoute = [(x.x, x.y) for x in route]\n\n        for y in range(self.MapHeight * 3):\n            brain.new_line()\n            brain.print(str(int(y / 3)) + \" \")\n            for x in range(self.MapWidth * 3):\n                xPoint = int(x / 3)\n                yPoint = int(y / 3)\n\n                currentTile = self.Map[yPoint][xPoint]\n\n                yRem = y % 3\n                xRem = x % 3\n\n                character = ''\n\n                if (yRem != 1 and xRem != 1):\n                    character = '#'\n\n                elif (yRem == 1 and xRem == 1):\n                    if (turtle.Pos.x == xPoint and turtle.Pos.y == yPoint):\n                        brain.set_print_color(GREEN)\n                        brain.print('T ')\n                        brain.set_print_color(BLACK)\n                        continue\n\n                    elif (turtle.Goal.x == xPoint and turtle.Goal.y == yPoint):\n                        brain.set_print_color(RED)\n                        brain.print('G ')\n                        brain.set_print_color(BLACK)\n                        continue\n\n                    elif (turtle.Start.x == xPoint and turtle.Start.y == yPoint):\n                        brain.set_print_color(RED)\n                        brain.print('S ')\n                        brain.set_print_color(BLACK)\n                        continue\n\n                    elif (route != None and (xPoint, yPoint) in tupleRoute):\n                        step = tupleRoute.index((xPoint, yPoint))\n\n                        if (step != -1):\n                            printing = str(step + 1) + (' ' if step < 9 else '')\n                            brain.set_print_color(BLUE)\n                            brain.print(printing)\n                            brain.set_print_color(BLACK)\n                            continue\n\n                        else:\n                            character = ' '\n                        \n                    else:\n                        character = ' '\n\n                elif (yRem == 0 and xRem == 1):\n                    character = self.GetCharacter(currentTile, Direction.NORTH)\n\n                elif (yRem == 1 and xRem == 0):\n                    character = self.GetCharacter(currentTile, Direction.WEST)\n\n                elif (yRem == 1 and xRem == 2):\n                    character = self.GetCharacter(currentTile, Direction.EAST)\n\n                elif (yRem == 2 and xRem == 1):\n                    character = self.GetCharacter(currentTile, Direction.SOUTH)\n\n                brain.print(character + \" \")\n\n        brain.new_line()\n        brain.print(\"  \")\n        for i in range(0, self.MapWidth):\n            brain.print((str(i) + \" \") * 3)\n\nclass Pathfinding:\n    Route = []\n    Goal = Point(0, 0)\n    Certainty = 0\n\n    class Node:\n        def __init__(self, x, y, totalCost, distanceTravelled, facing, node, isChecked):\n            self.x = x\n            self.y = y\n            self.TotalCost = totalCost\n            self.DistanceTravelled = distanceTravelled\n            self.PreviousNode = node\n            self.CurrentDirection = facing\n            self.IsChecked = isChecked\n\n    def Heuristic(self, point):\n        return abs(self.Goal.x - point.x) + abs(self.Goal.y - point.y)\n    \n    def GetRoute(self, successorNode):\n        route = []\n        checkingNode = successorNode\n        \n        checkedCount = 0\n\n        while (checkingNode.PreviousNode != None):\n            route.append(Point(checkingNode.x, checkingNode.y))\n\n            if (checkingNode.IsChecked):\n                checkedCount = checkedCount + 1\n\n            checkingNode = checkingNode.PreviousNode\n\n        if (len(route) > 0):\n            self.Certainty = checkedCount / len(route)\n\n        route.reverse()\n        return route\n\n    def CalculateStepCost(self, currentNode, direction, isDirectionChecked):\n        stepCost = 2\n\n        #Saves time if you don't have to turn\n        if (currentNode.CurrentDirection == direction):\n            stepCost = stepCost - 1\n\n        #More certaintanty means less likely to go the wrong way\n        if (isDirectionChecked):\n            stepCost = stepCost - 0.5\n\n        return stepCost\n\n\n    def CalculateRoute(self, current, facing, goal, theMap, guranteedRouteRequired=False):\n        self.Current = current\n        self.Route = []\n\n        routeFound = False\n        openNodes = [self.Node(current.x, current.y, 0, 0, facing, None, True)]\n        closedNodes = []\n        finalNodes = []\n\n        aStar = goal != \"undiscovered\" \n\n        while (not routeFound and len(openNodes) > 0):\n\n            currentNode = openNodes.pop(0)\n            nodeRoute = [(p.x, p.y) for p in self.GetRoute(currentNode)]\n            availableDirections = theMap.Map[currentNode.y][currentNode.x].AvailableDirections\n            checkedDirections = theMap.Map[currentNode.y][currentNode.x].CheckedDirections\n\n            for i in range(len(availableDirections)):\n                if (not availableDirections[i]):\n                    continue\n\n                if (not checkedDirections[i] and guranteedRouteRequired):\n                    continue\n\n                checkingPoint = Point(currentNode.x, currentNode.y)\n                checkingPoint = checkingPoint.NextPosition(int(i))\n                \n                if (currentNode.PreviousNode != None and (checkingPoint.x, checkingPoint.y) in nodeRoute):\n                    continue\n\n                stepCost = self.CalculateStepCost(currentNode, i, checkedDirections[i])\n                distanceTravelled = currentNode.DistanceTravelled + stepCost\n                totalCost = (self.Heuristic(checkingPoint) if aStar else 0) + distanceTravelled\n\n                successorNode = self.Node(checkingPoint.x, checkingPoint.y, totalCost, distanceTravelled, i, currentNode, checkedDirections[i])\n\n                if ((aStar and (successorNode.x, successorNode.y) == (goal.x, goal.y)) or (not aStar and theMap.Map[checkingPoint.y][checkingPoint.x].CheckedDirections.count(False) > 0)):\n                    routeFound = True\n                    self.Route = self.GetRoute(successorNode)\n                    break\n\n\n                if (len(openNodes) == 0):\n                    openNodes.append(successorNode)\n                    continue\n\n                nodePreviouslyChecked = False\n                \n                #Remove if the node has already been checked\n                for closedNode in closedNodes:\n                    if ((successorNode.x, successorNode.y) == (closedNode.x, closedNode.y) and closedNode.TotalCost < successorNode.TotalCost):\n                        nodePreviouslyChecked = True\n                        break\n\n                if (nodePreviouslyChecked):\n                    continue\n\n                inserted = False\n                removing = False\n\n                removeAt = 0\n                insertAt = 0\n\n                for node in range(len(openNodes)):\n                    if (not inserted and successorNode.TotalCost < openNodes[node].TotalCost):\n                        insertAt = node\n                        inserted = True\n\n                    if ((successorNode.x, successorNode.y) == (openNodes[node].x, openNodes[node].y)):\n                        if (inserted):\n                            removing = True\n                            removeAt = node\n                            break\n                        else:\n                            break\n\n                if (removing):\n                    openNodes.pop(removeAt)\n                \n                if (inserted):\n                    openNodes.insert(insertAt, successorNode)\n\n                elif(not removing and not inserted):\n                    openNodes.append(successorNode)\n\n            closedNodes.append(currentNode)\n\n        if (not routeFound):\n            PrintLine(\"No route to goal was found.\")\n            return []\n\n        return self.Route\n                               \n        \n\n\nclass TurtleInfo:\n    CurrentDirection = Direction.NORTH\n    Pos = Point(0, 0)\n    Start = Point(0, 0)\n    Goal = Point(0, 0)\n\n\n    def __init__(self, direction, start, goal):\n        self.Pos = start\n        self.Start = start\n        self.Goal = goal\n        self.CurrentDirection = direction\n\n    def Turn(self, direction):\n        drivetrain.turn_for(direction, 90, DEGREES)\n        if (direction == RIGHT):\n            self.CurrentDirection = Direction.RightFrom(self.CurrentDirection)\n\n        else:\n            self.CurrentDirection = Direction.LeftFrom(self.CurrentDirection)\n\n    def Forward(self):\n        drivetrain.drive_for(FORWARD, 250, MM, wait=True)\n        self.Pos = self.Pos.NextPosition(self.CurrentDirection)\n\n    #The distance between the sensor and the edge of the tile varies depending on orientation\n    def TileSensorDistance(self):\n        if (self.CurrentDirection == Direction.NORTH):\n            return 42\n\n        elif (self.CurrentDirection == Direction.EAST):\n            return 32\n\n        elif (self.CurrentDirection == Direction.SOUTH):\n            return 33\n\n        elif (self.CurrentDirection == Direction.WEST):\n            return 42\n\n\n    def ClosestWall(self):\n        distance = front_distance.get_distance(MM)\n        if (distance >= 3000): #3000 is the sensor distance when am object isn't deteted\n            return -1\n\n        tiles = round(round((distance - self.TileSensorDistance()) / 10) / 25)\n        return tiles\n\ndef PerformMoves(currentDirection, nextDirection, currentTile, boardDiscovery):\n    instruction = Direction.FastestRotation(turtle.CurrentDirection, nextDirection)\n\n    discoveryInstruction = currentTile.GetDiscoveryInstruction(currentDirection, nextDirection, boardDiscovery)\n\n    if (discoveryInstruction != DiscoveryInstruction.FASTEST):\n        if (discoveryInstruction == DiscoveryInstruction.CHECKLEFT):\n            Turn(LEFT)\n            Turn(RIGHT)\n        \n        elif (discoveryInstruction == DiscoveryInstruction.CHECKRIGHT):\n            Turn(RIGHT)\n            Turn(LEFT)\n\n        else:\n            rotations = 4 - instruction.Rotations\n            instruction.Rotations = rotations\n            instruction.RotationDirection = RIGHT if instruction.RotationDirection == LEFT else LEFT\n\n    for i in range(instruction.Rotations):\n        Turn(instruction.RotationDirection)\n\ndef NextInstruction(currentPos, nextPos, optimiseForTime):\n    global board, turtle\n\n    boardDiscovery = 0 if not optimiseForTime else board.DiscoveryPercentage()\n\n    nextDirection = Direction.RequiredDirection(currentPos, nextPos)\n    currentTile = board.GetTile(currentPos)\n\n    if (nextDirection == turtle.CurrentDirection and turtle.ClosestWall() == 0):\n        return False\n\n    PerformMoves(turtle.CurrentDirection, nextDirection, currentTile, boardDiscovery)\n    \n    if (turtle.ClosestWall() == 0):\n        return False\n\n    Forward()\n    return True\n\ndef Forward():\n    global board, turtle\n\n    turtle.Forward()\n    board.Discover(turtle.Pos, turtle.CurrentDirection, turtle.ClosestWall())\n\n\ndef Turn(direction):\n    global board, turtle\n\n    turtle.Turn(direction)\n    board.Discover(turtle.Pos, turtle.CurrentDirection, turtle.ClosestWall())\n\n\n\ndef PrintLine(text):\n    brain.new_line()\n    brain.print(text)\n\ndef FastestRouteToGoal():\n    board.Discover(turtle.Pos, turtle.CurrentDirection, turtle.ClosestWall())\n    route = calculator.CalculateRoute(turtle.Pos, turtle.CurrentDirection, turtle.Goal, board)\n\n    while ((turtle.Pos.x, turtle.Pos.y) != (turtle.Goal.x, turtle.Goal.y)):\n        \n        if (debugMode):\n            board.PrintBoard(turtle, route)\n            discoverPercent = int(board.DiscoveryPercentage() * 100)\n            PrintLine(\"Discovered \" + str(discoverPercent) + \"%\")\n            brain.new_line()\n\n        if (len(route) == 0):\n            return\n        nextPos = route.pop(0)\n\n\n        success = NextInstruction(turtle.Pos, nextPos, True)\n        route = calculator.CalculateRoute(turtle.Pos, turtle.CurrentDirection, turtle.Goal, board)\n\ndef ReturnHome():\n    routeBack = calculator.CalculateRoute(turtle.Pos, turtle.CurrentDirection, startPos, board, True)\n\n    if(debugMode):\n        board.PrintBoard(turtle, routeBack)\n        \n    for nextPos in routeBack:\n        NextInstruction(turtle.Pos, nextPos, True)\n\ndef MapRemainder():\n    while (board.DiscoveryPercentage() != 1):\n        route = calculator.CalculateRoute(turtle.Pos, turtle.CurrentDirection, \"undiscovered\", board)\n        board.PrintBoard(turtle, route)\n        PrintLine(\"\")\n        for step in route:\n            NextInstruction(turtle.Pos, step, False)\n\n    board.PrintBoard(turtle, [])\n\n\nbrain.clear()\n\nstartPos = Point(4, 7) #X, Y\nendPos = Point(3, 0)\nboard = Board()\n\nturtle = TurtleInfo(Direction.NORTH, startPos, endPos)\ndebugMode = True\n\ncalculator = Pathfinding()\n\n\ndef Main():\n    global board, turtle, calculator\n    drivetrain.drive_for(FORWARD, 20, MM)\n\n    PrintLine(\"Map Key.\")\n    PrintLine(\"\")\n    PrintLine(\"#: Wall\")\n    PrintLine(\"?: Undiscovered\")\n    PrintLine(\"T: The robot\")\n    PrintLine(\"G: The goal\")\n    PrintLine(\"S: The start position\")\n\n    FastestRouteToGoal()\n    PrintLine(\"Goal found, returning home.\")\n    \n    ReturnHome()\n    PrintLine(\"Successfully returned home, now discovering remainder of the map.\")\n\n    MapRemainder()\n    PrintLine(\"Map successfully discovered.\")\n\n\nvr_thread(Main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}